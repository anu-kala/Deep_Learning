# -*- coding: utf-8 -*-
"""Cyber_Security_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qYlxwGVYkcUdSu-lYidheHXef0kOOHQo
"""

from google.colab import drive
drive.mount('/content/drive')

import os
os.chdir('/content/drive/My Drive/Colab Notebooks')

import pandas as pd
import numpy as np

from sklearn.preprocessing import LabelEncoder,OneHotEncoder,StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
import tensorflow as tf
from keras.models import Sequential
from keras.layers import Dense
import seaborn as sns
import matplotlib as plt
from sklearn.compose import ColumnTransformer

df = pd.read_csv('cybersecurity_intrusion_data.csv')
df

df.columns

df.shape

df1=df.describe()
df1

df.drop(columns=['session_id'],inplace=True)

df.columns

df.duplicated().sum()

df.isna().sum()

df.isnull().sum().sum()

df.dropna(inplace=True)

df.isnull().sum().sum()

encoder = LabelEncoder()

elements = ['protocol_type','encryption_used','browser_type']
for e in elements:
  df[e] = encoder.fit_transform(df[e])

df.head()

sns.histplot(x='network_packet_size',data=df)

sns.countplot(x='protocol_type',data=df)

sns.countplot(x='login_attempts',data=df)

sns.countplot(x='encryption_used',data=df)

x = df.drop(columns=['attack_detected'],axis=1)
y = df['attack_detected']

x=np.array(x)
x[1]

ct = ColumnTransformer([('encoder', OneHotEncoder(), [1])], remainder='passthrough')
x = np.array(ct.fit_transform(x))
x

x[1]

x_train , x_test , y_train , y_test = train_test_split(x,y,test_size=0.3)

x_train.shape

std = StandardScaler()
std.fit(x_train)
x_train = std.transform(x_train)
x_test = std.transform(x_test)



ann = tf.keras.models.Sequential()
ann

ann.add(tf.keras.layers.Dense(units = 6, activation="relu", input_dim = 11))

# adding of hidden layer
ann.add(tf.keras.layers.Dense(units = 6, activation="relu"))


# adding output layer
ann.add(tf.keras.layers.Dense(units = 1, activation="sigmoid"))

ann.compile(
  optimizer = "adam",
  loss = "binary_crossentropy",
  metrics = ["accuracy"]
)

ann.fit(x_train, y_train, batch_size=32, epochs=100)

ann.summary()

y_train

ytrain_pred = ann.predict(x_train)
ytrain_pred

x_train

ytrain_pred_list = []

for i in ann.predict(x_train) > 0.5:
  if i>=0.5:
      ytrain_pred_list.append(1)
  else:
    ytrain_pred_list.append(0)

from sklearn.metrics import confusion_matrix, accuracy_score

acc = accuracy_score(y_train, ytrain_pred_list)
acc

con = confusion_matrix(y_train, ytrain_pred_list)
con

sns.heatmap(con, annot=True)

x[1]

y

if ann.predict(std.transform(x[[1]]))[0][0] >= 0.5:
  print("Attack detected")
else:
  print("Attack not exit")

df.columns

def MyPrediction( protocol_type_0, protocol_type_1, protocol_type_2, network_packet_size,login_attempts,session_duration, encryption_used, ip_reputation_score,
       failed_logins, browser_type, unusual_time_access):
  input_transform = std.transform([[protocol_type_0, protocol_type_1, protocol_type_2,network_packet_size,login_attempts,
       session_duration, encryption_used, ip_reputation_score,failed_logins, browser_type, unusual_time_access]])

  if ann.predict(input_transform)[0][0] >= 0.5:
    print("attack detected")
  else:
    print(" attack not detected")

MyPrediction(0,1,0,629,3,75.044262,1,0.739164	,2,0,0)

df.head()